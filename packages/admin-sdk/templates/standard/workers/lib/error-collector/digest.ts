/**
 * Warning Digest Module
 *
 * Handles daily digest creation for P4 warnings.
 * Groups warnings by type (normalized fingerprint) and creates one issue per type.
 */

import type { Env, PendingDigestWarning, ScriptMapping } from './types';
import { GitHubClient } from './github';

/**
 * Get today's date in YYYY-MM-DD format (UTC)
 */
export function getDigestDate(): string {
  return new Date().toISOString().slice(0, 10);
}

/**
 * Get yesterday's date in YYYY-MM-DD format (UTC)
 * Used for creating digests of the previous day's warnings
 */
export function getYesterdayDigestDate(): string {
  const yesterday = new Date();
  yesterday.setUTCDate(yesterday.getUTCDate() - 1);
  return yesterday.toISOString().slice(0, 10);
}

/**
 * Query pending warnings grouped by script and fingerprint
 */
export async function getPendingWarnings(
  db: D1Database,
  digestDate: string
): Promise<Map<string, PendingDigestWarning[]>> {
  // Get all pending_digest warnings from yesterday (or specified date)
  const result = await db
    .prepare(
      `
      SELECT
        id,
        fingerprint,
        script_name,
        project,
        github_repo,
        normalized_message,
        last_exception_message as raw_message,
        last_seen_at as event_timestamp,
        occurrence_count
      FROM error_occurrences
      WHERE status = 'pending_digest'
        AND error_type = 'warning'
        AND date(last_seen_at, 'unixepoch') = ?
      ORDER BY script_name, fingerprint, last_seen_at
    `
    )
    .bind(digestDate)
    .all<PendingDigestWarning>();

  // Group by script_name:fingerprint
  const grouped = new Map<string, PendingDigestWarning[]>();

  for (const warning of result.results || []) {
    const key = `${warning.script_name}:${warning.fingerprint}`;
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key)!.push(warning);
  }

  return grouped;
}

/**
 * Format the digest issue body
 */
function formatDigestBody(
  warnings: PendingDigestWarning[],
  digestDate: string,
  mapping: ScriptMapping
): string {
  const totalOccurrences = warnings.reduce((sum, w) => sum + w.occurrence_count, 0);
  const firstSeen = new Date(
    Math.min(...warnings.map((w) => w.event_timestamp)) * 1000
  ).toISOString();
  const lastSeen = new Date(
    Math.max(...warnings.map((w) => w.event_timestamp)) * 1000
  ).toISOString();

  // Extract normalized message from first warning
  const normalizedMessage = warnings[0]?.normalized_message || 'Unknown warning';

  let body = `## Daily Warning Digest: ${normalizedMessage}\n\n`;

  body += `| | |\n|---|---|\n`;
  body += `| **Date** | ${digestDate} |\n`;
  body += `| **Project** | ${mapping.displayName} |\n`;
  body += `| **Worker** | \`${warnings[0]?.script_name}\` |\n`;
  body += `| **Total Occurrences** | ${totalOccurrences} |\n`;
  body += `| **Unique Events** | ${warnings.length} |\n`;
  body += `| **First Seen** | ${firstSeen.slice(11, 19)} UTC |\n`;
  body += `| **Last Seen** | ${lastSeen.slice(11, 19)} UTC |\n\n`;

  // Timeline table (show up to 50 occurrences)
  body += `### Timeline\n\n`;
  body += `| Time (UTC) | Occurrences | Details |\n`;
  body += `|------------|-------------|----------|\n`;

  const displayWarnings = warnings.slice(0, 50);
  for (const w of displayWarnings) {
    const time = new Date(w.event_timestamp * 1000).toISOString().slice(11, 19);
    const details = (w.raw_message || '').slice(0, 60).replace(/\|/g, '\\|');
    body += `| ${time} | ${w.occurrence_count} | ${details}${w.raw_message && w.raw_message.length > 60 ? '...' : ''} |\n`;
  }

  if (warnings.length > 50) {
    body += `| ... | ... | *(${warnings.length - 50} more occurrences)* |\n`;
  }

  body += `\n`;

  // Sample log entry
  if (warnings[0]?.raw_message) {
    body += `### Sample Log Entry\n`;
    body += `\`\`\`\n${warnings[0].raw_message.slice(0, 500)}\n\`\`\`\n\n`;
  }

  // Quick links
  body += `### Quick Links\n`;
  body += `- [Worker Dashboard](https://dash.cloudflare.com/?to=/:account/workers/services/view/${warnings[0]?.script_name})\n`;
  body += `- [Repository](https://github.com/${mapping.repository})\n`;
  body += `- [CLAUDE.md](https://github.com/${mapping.repository}/blob/main/CLAUDE.md)\n\n`;

  // Investigation guidance
  body += `### Action Required\n`;
  body += `This warning occurred ${totalOccurrences} times on ${digestDate}. Consider:\n`;
  body += `1. Is this expected behavior? If so, consider reducing log level to \`debug\`\n`;
  body += `2. Does this indicate a performance issue that should be addressed?\n`;
  body += `3. Can the underlying condition be fixed to prevent the warning?\n\n`;

  body += `---\n`;
  body += `_Daily digest generated by Platform Error Collector_\n`;

  return body;
}

/**
 * Create or update a digest issue for a warning type
 */
async function createOrUpdateDigestIssue(
  db: D1Database,
  github: GitHubClient,
  warnings: PendingDigestWarning[],
  mapping: ScriptMapping,
  digestDate: string
): Promise<{ issueNumber: number; issueUrl: string }> {
  const [owner, repo] = mapping.repository.split('/');
  const fingerprint = warnings[0]?.fingerprint || '';
  const scriptName = warnings[0]?.script_name || '';
  const normalizedMessage = warnings[0]?.normalized_message || 'Unknown warning';

  // Check if we already have a digest issue for this fingerprint today
  const existing = await db
    .prepare(
      `
      SELECT github_issue_number, github_issue_url
      FROM warning_digests
      WHERE digest_date = ? AND script_name = ? AND fingerprint = ?
    `
    )
    .bind(digestDate, scriptName, fingerprint)
    .first<{ github_issue_number: number; github_issue_url: string }>();

  const body = formatDigestBody(warnings, digestDate, mapping);
  const title = `[${scriptName}] Daily Digest: ${normalizedMessage.slice(0, 50)} (${digestDate})`;
  const totalOccurrences = warnings.reduce((sum, w) => sum + w.occurrence_count, 0);

  if (existing?.github_issue_number) {
    // Update existing issue
    await github.updateIssue({
      owner,
      repo,
      issue_number: existing.github_issue_number,
      body,
    });

    // Update digest record
    await db
      .prepare(
        `
        UPDATE warning_digests
        SET occurrence_count = ?,
            last_occurrence_at = unixepoch(),
            updated_at = unixepoch()
        WHERE digest_date = ? AND script_name = ? AND fingerprint = ?
      `
      )
      .bind(totalOccurrences, digestDate, scriptName, fingerprint)
      .run();

    return {
      issueNumber: existing.github_issue_number,
      issueUrl: existing.github_issue_url,
    };
  }

  // Create placeholder record FIRST to prevent race condition
  // If another invocation is processing the same digest, this INSERT will fail
  // due to UNIQUE(digest_date, script_name, fingerprint) constraint
  const id = crypto.randomUUID();
  const now = Math.floor(Date.now() / 1000);

  try {
    await db
      .prepare(
        `
        INSERT INTO warning_digests (
          id, digest_date, script_name, fingerprint, normalized_message,
          github_repo, github_issue_number, github_issue_url,
          occurrence_count, first_occurrence_at, last_occurrence_at,
          created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, NULL, NULL, ?, ?, ?, ?, ?)
      `
      )
      .bind(
        id,
        digestDate,
        scriptName,
        fingerprint,
        normalizedMessage,
        mapping.repository,
        totalOccurrences,
        now,
        now,
        now,
        now
      )
      .run();
  } catch (e) {
    // Unique constraint violation - another invocation already processing this digest
    // Re-fetch the existing record and return it
    console.log(`Digest already being processed for ${scriptName}:${fingerprint}, skipping`);
    const existing = await db
      .prepare(
        `
        SELECT github_issue_number, github_issue_url
        FROM warning_digests
        WHERE digest_date = ? AND script_name = ? AND fingerprint = ?
      `
      )
      .bind(digestDate, scriptName, fingerprint)
      .first<{ github_issue_number: number; github_issue_url: string }>();

    if (existing?.github_issue_number) {
      return {
        issueNumber: existing.github_issue_number,
        issueUrl: existing.github_issue_url,
      };
    }
    // Other invocation is creating the issue — retry with exponential backoff
    for (const delayMs of [1000, 2000, 4000]) {
      await new Promise((resolve) => setTimeout(resolve, delayMs));
      const retried = await db
        .prepare(
          `
          SELECT github_issue_number, github_issue_url
          FROM warning_digests
          WHERE digest_date = ? AND script_name = ? AND fingerprint = ?
        `
        )
        .bind(digestDate, scriptName, fingerprint)
        .first<{ github_issue_number: number; github_issue_url: string }>();

      if (retried?.github_issue_number) {
        return {
          issueNumber: retried.github_issue_number,
          issueUrl: retried.github_issue_url,
        };
      }
    }

    return {
      issueNumber: 0,
      issueUrl: '',
    };
  }

  // Now create the GitHub issue (we hold the "lock" via the DB record)
  const issue = await github.createIssue({
    owner,
    repo,
    title,
    body,
    labels: ['cf:error:auto-generated', 'cf:error:warning', 'cf:digest'],
    type: 'Task',
  });

  // Update the placeholder record with the actual issue details
  await db
    .prepare(
      `
      UPDATE warning_digests
      SET github_issue_number = ?,
          github_issue_url = ?,
          updated_at = unixepoch()
      WHERE id = ?
    `
    )
    .bind(issue.number, issue.html_url, id)
    .run();

  return {
    issueNumber: issue.number,
    issueUrl: issue.html_url,
  };
}

/**
 * Process all pending warnings and create digest issues
 * Called by the daily cron job
 */
export async function processWarningDigests(env: Env): Promise<{
  processed: number;
  issuesCreated: number;
  issuesUpdated: number;
}> {
  const github = new GitHubClient(env);
  const digestDate = getYesterdayDigestDate(); // Process yesterday's warnings

  console.log(`Processing warning digests for ${digestDate}`);

  // Get all pending warnings grouped by script:fingerprint
  const grouped = await getPendingWarnings(env.PLATFORM_DB, digestDate);

  let processed = 0;
  let issuesCreated = 0;
  let issuesUpdated = 0;

  for (const [key, warnings] of grouped) {
    const [scriptName] = key.split(':');

    // Get script mapping
    const mappingStr = await env.PLATFORM_CACHE.get(`SCRIPT_MAP:${scriptName}`);
    if (!mappingStr) {
      console.log(`No mapping found for script: ${scriptName}, skipping digest`);
      continue;
    }

    const mapping = JSON.parse(mappingStr) as ScriptMapping;

    try {
      // Create or update digest issue
      const result = await createOrUpdateDigestIssue(
        env.PLATFORM_DB,
        github,
        warnings,
        mapping,
        digestDate
      );

      // Mark warnings as digested
      const ids = warnings.map((w) => w.id);
      for (const id of ids) {
        await env.PLATFORM_DB.prepare(
          `
          UPDATE error_occurrences
          SET status = 'digested',
              digest_date = ?,
              digest_issue_number = ?,
              updated_at = unixepoch()
          WHERE id = ?
        `
        )
          .bind(digestDate, result.issueNumber, id)
          .run();
      }

      processed += warnings.length;

      // Check if this was a new issue or update
      const isNew = !warnings.some((w) => w.fingerprint === key.split(':')[1]);
      if (isNew) {
        issuesCreated++;
      } else {
        issuesUpdated++;
      }

      console.log(
        `Digest created/updated for ${scriptName}: ${warnings[0]?.normalized_message} (${warnings.length} occurrences) → issue #${result.issueNumber}`
      );
    } catch (e) {
      console.error(`Failed to create digest for ${key}: ${e}`);
    }
  }

  console.log(
    `Digest processing complete: ${processed} warnings processed, ${issuesCreated} issues created, ${issuesUpdated} issues updated`
  );

  return { processed, issuesCreated, issuesUpdated };
}

/**
 * Store a warning for later digest (instead of creating immediate issue)
 */
export async function storeWarningForDigest(
  db: D1Database,
  kv: KVNamespace,
  fingerprint: string,
  scriptName: string,
  project: string,
  repo: string,
  normalizedMessage: string,
  rawMessage: string
): Promise<void> {
  const id = crypto.randomUUID();
  const now = Math.floor(Date.now() / 1000);

  await db
    .prepare(
      `
      INSERT INTO error_occurrences (
        id, fingerprint, script_name, project, error_type, priority,
        github_repo, status, normalized_message, last_exception_message,
        first_seen_at, last_seen_at, occurrence_count,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, 'warning', 'P4', ?, 'pending_digest', ?, ?, ?, ?, 1, ?, ?)
      ON CONFLICT(fingerprint) DO UPDATE SET
        occurrence_count = occurrence_count + 1,
        last_seen_at = excluded.last_seen_at,
        last_exception_message = excluded.last_exception_message,
        updated_at = excluded.updated_at
    `
    )
    .bind(
      id,
      fingerprint,
      scriptName,
      project,
      repo,
      normalizedMessage,
      rawMessage,
      now,
      now,
      now,
      now
    )
    .run();
}
