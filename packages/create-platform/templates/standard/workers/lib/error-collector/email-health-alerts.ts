/**
 * Email Health Alert Handler
 *
 * Processes email health check failures from platform-email-healthcheck
 * and creates GitHub issues in the correct website repository.
 *
 * Uses existing GitHubClient and deduplication patterns from error-collector.
 *
 * @module workers/lib/error-collector/email-health-alerts
 */

import type { Env, EmailHealthAlertEvent } from './types';
import { GitHubClient } from './github';

// TODO: Set your GitHub organisation and dashboard URL
const GITHUB_ORG = 'your-github-org';
const DASHBOARD_URL = 'https://your-dashboard.example.com';
const GATUS_URL = 'https://your-status.example.com';
const EMAIL_HEALTHCHECK_URL = 'https://platform-email-healthcheck.your-subdomain.workers.dev';

/**
 * KV prefix for email health alert deduplication.
 * Format: EMAIL_HEALTH:{brand}:{check_type}:{date}
 * One issue per brand per check type per day maximum.
 */
const EMAIL_HEALTH_PREFIX = 'EMAIL_HEALTH';

/** Labels applied to email health alert issues */
const EMAIL_HEALTH_LABELS = ['cf:email-health', 'cf:priority:p2', 'cf:auto-generated'];

/** Get today's date key in YYYY-MM-DD format (UTC) */
function getDateKey(): string {
  return new Date().toISOString().slice(0, 10);
}

/**
 * Check if an email health alert has already been created for this brand+check today.
 * @returns Issue number if exists, null otherwise
 */
async function checkDedup(
  kv: KVNamespace,
  brandId: string,
  checkType: string
): Promise<number | null> {
  const key = `${EMAIL_HEALTH_PREFIX}:${brandId}:${checkType}:${getDateKey()}`;
  const existing = await kv.get(key);
  return existing ? parseInt(existing, 10) : null;
}

/** Record that an email health alert issue was created for today. */
async function setDedup(
  kv: KVNamespace,
  brandId: string,
  checkType: string,
  issueNumber: number
): Promise<void> {
  const key = `${EMAIL_HEALTH_PREFIX}:${brandId}:${checkType}:${getDateKey()}`;
  // TTL of 25 hours to cover the full day plus buffer
  await kv.put(key, String(issueNumber), { expirationTtl: 90000 });
}

// TODO: Map your brand IDs to display names
/** Brand display names for issue titles */
const BRAND_NAMES: Record<string, string> = {
  // Example:
  // mybrand: 'My Brand',
  // anotherbrand: 'Another Brand',
};

// TODO: Map your brand IDs to email domains
/** Brand domain mappings for health check URLs */
const BRAND_DOMAINS: Record<string, string> = {
  // Example:
  // mybrand: 'mybrand.com',
  // anotherbrand: 'anotherbrand.io',
};

/** Format the GitHub issue body for email health check failures. */
function formatIssueBody(event: EmailHealthAlertEvent): string {
  const brandName = BRAND_NAMES[event.brand_id] ?? event.brand_id;
  const brandDomain = BRAND_DOMAINS[event.brand_id] ?? `${event.brand_id}.example.com`;
  const now = new Date().toISOString();

  const failureRows = event.failures
    .map((f) => `| \`${f.check_type}\` | ${f.error_msg} |`)
    .join('\n');

  return `## Email Health Check Failures

| | |
|---|---|
| **Brand** | \`${event.brand_id}\` (${brandName}) |
| **Failures** | ${event.failures.length} check(s) |
| **Run ID** | \`${event.run_id}\` |
| **Detected** | ${now} |

### Failing Checks

| Check | Error |
|-------|-------|
${failureRows}

### Check Types Reference

| Check | What It Validates |
|-------|-------------------|
| \`brand_config\` | Brand exists in D1, status=active, from_email set |
| \`templates\` | confirmation + welcome email templates exist and active |
| \`confirmation_page\` | /confirmed page returns 200 on website |
| \`email_api_health\` | email.{domain}/email/_health returns ok |
| \`resend_dns\` | Resend domain verified, DKIM + SPF records verified |
| \`dmarc\` | DMARC record present with enforcing policy |
| \`recent_sends\` | At least 1 email sent in last 7 days |

### Investigation Steps

1. **Run manual health check** for this brand:
   \`\`\`bash
   curl "${EMAIL_HEALTHCHECK_URL}/healthcheck?brand=${event.brand_id}"
   \`\`\`

2. **Check health check history**:
   \`\`\`bash
   curl "${EMAIL_HEALTHCHECK_URL}/history?brand=${event.brand_id}&limit=20"
   \`\`\`

3. **Check email API directly**:
   \`\`\`bash
   curl "https://email.${brandDomain}/email/_health"
   \`\`\`

4. **Check Resend domain status** via Resend dashboard or API

5. **Check Gatus** for platform-email-healthcheck heartbeat:
   - [Gatus Status Page](${GATUS_URL})

### Quick Links

- [Platform Dashboard](${DASHBOARD_URL})
- [Resend Dashboard](https://resend.com/domains)
- [Repository](https://github.com/${event.repository})
- [Email Health Check Worker](https://github.com/${GITHUB_ORG}/platform/blob/main/workers/platform-email-healthcheck.ts)
- [Email System Docs](https://github.com/${GITHUB_ORG}/platform/blob/main/docs/quickrefs/email-system.md)

---
Generated by [Platform Email Health Check](https://github.com/${GITHUB_ORG}/platform/blob/main/workers/platform-email-healthcheck.ts)
`;
}

/**
 * Process email health alert failures and create GitHub issues.
 *
 * Creates one issue per failing check type (deduped per brand+check+day).
 * Returns results for each failure processed.
 */
export async function processEmailHealthAlerts(
  event: EmailHealthAlertEvent,
  env: Env
): Promise<{
  processed: number;
  skipped: number;
  issues: Array<{ check_type: string; issueNumber: number; issueUrl: string }>;
  skippedChecks: Array<{ check_type: string; reason: string }>;
}> {
  const results = {
    processed: 0,
    skipped: 0,
    issues: [] as Array<{ check_type: string; issueNumber: number; issueUrl: string }>,
    skippedChecks: [] as Array<{ check_type: string; reason: string }>,
  };

  // Parse owner/repo
  const [owner, repo] = event.repository.split('/');
  if (!owner || !repo) {
    results.skippedChecks.push(
      ...event.failures.map((f) => ({
        check_type: f.check_type,
        reason: `Invalid repository format: ${event.repository}`,
      }))
    );
    results.skipped = event.failures.length;
    return results;
  }

  const github = new GitHubClient(env);
  const brandName = BRAND_NAMES[event.brand_id] ?? event.brand_id;

  for (const failure of event.failures) {
    // Check dedup â€” one issue per brand per check type per day
    const existingIssue = await checkDedup(env.PLATFORM_CACHE, event.brand_id, failure.check_type);
    if (existingIssue) {
      results.skipped++;
      results.skippedChecks.push({
        check_type: failure.check_type,
        reason: `Issue #${existingIssue} already created today`,
      });
      continue;
    }

    try {
      // Create a focused issue for this specific check failure
      const issue = await github.createIssue({
        owner,
        repo,
        title: `Email Health: ${brandName} ${failure.check_type} failing`,
        body: formatIssueBody({
          ...event,
          failures: [failure], // Only include this specific failure
        }),
        labels: EMAIL_HEALTH_LABELS,
      });

      console.log(`Created email health issue #${issue.number} for ${event.brand_id}:${failure.check_type}`);

      // Record dedup
      await setDedup(env.PLATFORM_CACHE, event.brand_id, failure.check_type, issue.number);

      results.processed++;
      results.issues.push({
        check_type: failure.check_type,
        issueNumber: issue.number,
        issueUrl: issue.html_url,
      });
    } catch (error) {
      console.error(`Failed to create email health issue for ${event.brand_id}:${failure.check_type}:`, error);
      results.skipped++;
      results.skippedChecks.push({
        check_type: failure.check_type,
        reason: `GitHub API error: ${error instanceof Error ? error.message : String(error)}`,
      });
    }
  }

  // Create dashboard notification (summary for all failures)
  if (results.processed > 0 && env.NOTIFICATIONS_API) {
    try {
      await env.NOTIFICATIONS_API.fetch(
        'https://platform-notifications.internal/notifications',
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            category: 'email_health',
            source: 'platform-email-healthcheck',
            source_id: event.run_id,
            title: `Email Health: ${brandName} has ${event.failures.length} failing check(s)`,
            description: event.failures.map((f) => `${f.check_type}: ${f.error_msg}`).join('; '),
            priority: 'medium',
            action_url: results.issues[0]?.issueUrl,
            action_label: 'View Issue',
            project: 'platform',
          }),
        }
      );
    } catch (e) {
      // Non-blocking
      console.error('Failed to create dashboard notification:', e);
    }
  }

  return results;
}
